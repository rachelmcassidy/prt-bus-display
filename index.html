<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Bus Display</title>
  <style>
    body { font-family: sans-serif; background: black; color: white; text-align: center; margin-top: 3em; }
    .route { font-size: 2em; margin-top: 1em; text-align: left; }
    .arrival { font-size: 1.5em; margin: 0.5em 0; }
    .scheduled { color: yellow; font-style: italic; }
  </style>
  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

</head>
<body>
  <h1 id="current-time">Current Time: Loading...</h1>
  <div id="bus-info">Loading...</div>
  <script>
    const API_KEY = "jB5f4FaqsrnktmSPx34QsykWT";  // Replace this
    const CORS_PROXY = "https://api.allorigins.win/raw?url=";
    
    // Host your GTFS CSV files somewhere public and accessible:
    const GTFS_BASE_URL = "https://rachelmcassidy.github.io/prt-bus-display/gtfs/"; // REPLACE with your hosted GTFS CSV folder URL


    // Define stops with their routes and directions
    const stops = [
      { 
        id: "29", 
        routes: [
          { route: "61A", directions: ["OUT"] },
          { route: "61B", directions: ["OUT"] },
          { route: "61C", directions: ["OUT"] },
          { route: "61D", directions: ["OUT"] },
          { route: "67", directions: ["OUT"] },
          { route: "69", directions: ["OUT"] }
        ]
      },
      { 
        id: "7639", 
        routes: [
          { route: "67", directions: ["IN"] },
          { route: "69", directions: ["IN"] }
        ]
      }
    ];

    // === GTFS Static CSV data caches ===
    let gtfsStopTimes = null;
    let gtfsTrips = null;
    let gtfsRoutes = null;
    let gtfsCalendar = null;

    // Helper: fetch and parse CSV using PapaParse
    async function fetchAndParseCSV(url) {
      const response = await fetch(url);
      const text = await response.text();
      return new Promise((resolve) => {
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data)
        });
      });
    }

    // Load all GTFS CSV files once at startup
    async function loadGtfsStaticData() {
      [gtfsStopTimes, gtfsTrips, gtfsRoutes, gtfsCalendar] = await Promise.all([
        fetchAndParseCSV(GTFS_BASE_URL + "my_times.txt"),
        fetchAndParseCSV(GTFS_BASE_URL + "trips.txt"),
        fetchAndParseCSV(GTFS_BASE_URL + "calendar.txt")
      ]);
    }

    // Parse time like "25:10:00" to a Date object today (+1 day if time < current time)
    function parseGtfsTimeToDate(timeStr) {
      const [h, m, s] = timeStr.split(":").map(Number);
      let hours = h % 24;
      const d = new Date();
      d.setHours(hours, m, s, 0);

      // If original hour > 23, add 1 day
      if (h >= 24) {
        d.setDate(d.getDate() + 1);
      }

      return d;
    }

    // Get active service_ids for today from calendar.txt
    function getActiveServiceIds() {
      const today = new Date();
      const yyyyMMdd = today.toISOString().slice(0, 10).replace(/-/g, "");

      // GTFS calendar weekday mapping: Monday=1, Sunday=7
      const weekdayIndex = today.getDay() === 0 ? 7 : today.getDay(); // Sunday=0 in JS, 7 in GTFS
      const weekdayMap = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];

      return gtfsCalendar
        .filter(row => {
          return (
            row.start_date <= yyyyMMdd &&
            row.end_date >= yyyyMMdd &&
            row[weekdayMap[weekdayIndex - 1]] === "1"
          );
        })
        .map(row => row.service_id);
    }

    // Filter trips to only active service trips
    function getActiveTrips(activeServiceIds) {
      const trips = {};
      gtfsTrips.forEach(row => {
        if (activeServiceIds.includes(row.service_id)) {
          trips[row.trip_id] = {
            route_id: row.route_id,
            direction_id: row.direction_id,
          };
        }
      });
      return trips;
    }

    // Extract scheduled arrivals for a stop within the next hour grouped by route and direction
    function getScheduledTimesForStop(stopId, tripsMap, routeMap) {
      const now = new Date();
      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);
      const scheduleByRouteDir = {};

      gtfsStopTimes.forEach(row => {
        if (row.stop_id !== stopId) return;
        const trip = tripsMap[row.trip_id];
        if (!trip) return;

        const arrivalDate = parseGtfsTimeToDate(row.arrival_time);
        if (arrivalDate >= now && arrivalDate <= oneHourLater) {
          const routeName = trip.route_id;
          const direction = trip.direction_id === "1" ? "IN" : "OUT";
          const key = `${routeName} (${direction})`;
          if (!scheduleByRouteDir[key]) scheduleByRouteDir[key] = [];
          // Format time as HH:MM
          const hhmm = arrivalDate.toTimeString().slice(0, 5);
          scheduleByRouteDir[key].push(hhmm);
        }
      });

      return scheduleByRouteDir;
    }


    function updateTime() {
      const now = new Date();
      const timeString = now.toLocaleTimeString();
      document.getElementById("current-time").textContent = `Current Time: ${timeString}`;
    }

    async function fetchData() {
      updateTime(); // Update time each time we fetch data
      try {
        const div = document.getElementById("bus-info");
        div.innerHTML = "";

        // Fetch data for all stops
        for (let i = 0; i < stops.length; i++) {
          const stop = stops[i];
          const API_URL = `${CORS_PROXY}${encodeURIComponent(`https://truetime.portauthority.org/bustime/api/v3/getpredictions?key=${API_KEY}&format=json&stpid=${stop.id}&rtpidatafeed=Port%20Authority%20Bus`)}`;
          
          const response = await fetch(API_URL);
          const data = await response.json();
          
          displayStopData(data, stop.id, stop.routes, div);
          
          // Add separator between stops (except for last stop)
          if (i < stops.length - 1) {
            div.innerHTML += "<hr style='margin: 2em 0; border: 1px solid #555;'>";
          }
        }
      } catch (err) {
        console.error("Fetch error:", err);
        document.getElementById("bus-info").innerHTML = `Error loading data: ${err.message}`;
      }
    }

    function displayStopData(data, stopId, routesToShow, div, schedules) {
      if (data['bustime-response']?.error) {
        const errorMsg = data['bustime-response'].error[0]?.msg || "Unknown API error";
        div.innerHTML += `<p>API Error for Stop ${stopId}: ${errorMsg}</p>`;
        return;
      }

      const preds = data['bustime-response']?.prd || [];
      
      // Get stop name (from predictions if available, otherwise use stop ID)
      const stopName = preds.length > 0 ? preds[0]?.stpnm : `Stop ${stopId}`;
      div.innerHTML += `<h2 style="font-size: 1.8em; margin-bottom: 1em; color: #ccc;">${stopName}</h2>`;

      // Group predictions by route and direction
      const grouped = {};
      preds.forEach(pred => {
        const direction = pred.rtdir === "INBOUND" ? "IN" : pred.rtdir === "OUTBOUND" ? "OUT" : "";
        const key = `${pred.rt} (${direction})`;
        if (!grouped[key]) {
          grouped[key] = [];
        }
        const mins = pred.prdctdn === "DUE" ? "Due" : `${pred.prdctdn} min`;
        grouped[key].push(mins);
      });

      // Display routes in the order specified in routesToShow
      routesToShow.forEach(routeConfig => {
        routeConfig.directions.forEach(direction => {
          const key = `${routeConfig.route} (${direction})`;
          
          if (grouped[key]) {
            div.innerHTML += `<div class="route">${key}: ${grouped[key].join(', ')}</div>`;
          } else {
            div.innerHTML += `<div class="route">${key}: None</div>`;
          }

          // Scheduled times display (those not in predictions)
          if (schedules && schedules[key]) {
            // Filter out scheduled times that appear in predictions (approximate)
            const predsMinutes = new Set(
              (groupedPreds[key] || [])
                .filter(p => p !== "Due")
                .map(p => parseInt(p))
                .filter(n => !isNaN(n))
            );
            const now = new Date();

            const filteredScheduled = schedules[key].filter(timeStr => {
              // Convert scheduled HH:MM to minutes from now
              const [hh, mm] = timeStr.split(":").map(Number);
              const schedDate = new Date(now);
              schedDate.setHours(hh, mm, 0, 0);
              const diffMins = (schedDate - now) / (1000 * 60);
              // Keep if diffMins not in predsMinutes (+-2 min tolerance)
              return !Array.from(predsMinutes).some(pm => Math.abs(pm - diffMins) <= 2);
            });

            if (filteredScheduled.length > 0) {
              div.innerHTML += `<div class="route scheduled">${key} Scheduled: ${filteredScheduled.join(", ")}</div>`;
            }
          }
        });
      });
    }

    fetchData();
    setInterval(fetchData, 30000);
  </script>
</body>
</html>
